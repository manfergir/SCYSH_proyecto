/* Private functions to implement MQTT app */
#include <mqtt_priv.h>
#include "../../Libraries/coreMQTT/source/core_mqtt.h"
#include "stm32l475e_iot01.h"

static uint8_t ucSharedBuffer[ NETWORK_BUFFER_SIZE ];
static MQTTFixedBuffer_t xBuffer = { ucSharedBuffer, NETWORK_BUFFER_SIZE };

typedef struct topicFilterContext {
    const char * pcTopicFilter;
    MQTTSubAckStatus_t xSubAckStatus;
} topicFilterContext_t;

static topicFilterContext_t xTopicFilterContext[ TOPIC_COUNT ] = {
    { pcTempTopic, MQTTSubAckFailure }
};

static uint16_t usSubscribePacketIdentifier;
static uint32_t ulGlobalEntryTimeMs;

TransportStatus_t prvConnectToServer( NetworkContext_t * pxNetworkContext )
{
   TransportStatus_t xNetworkStatus = (TransportStatus_t) -1;
   uint8_t ret;
   uint8_t ipaddr[4] = MQTT_BROKER_ENDPOINT_IP;

    LOG(("--- [DEBUG] Iniciando prvConnectToServer... ---\r\n"));

    do {
        LOG( ( "Create a TCP connection to %s:%d.\n", MQTT_BROKER_ENDPOINT, MQTT_BROKER_PORT ) );

        ret = WIFI_OpenClientConnection(SOCKET, WIFI_TCP_PROTOCOL, "mqtt", ipaddr , MQTT_BROKER_PORT, 0);

        // Aceptamos 0 (OK) y 1 (REQ_DATA)
        if((ret != WIFI_STATUS_OK) && (ret != ES_WIFI_STATUS_REQ_DATA_STAGE)) {
			LOG(("Error in opening MQTT connection: %d\n", ret));
            xNetworkStatus = (TransportStatus_t) -1;
			osDelay(pdMS_TO_TICKS(5000));
		} else {
            LOG(("--- [EXITO] SOCKET ABIERTO (Codigo: %d) ---\r\n", ret));
	        pxNetworkContext->socket = SOCKET;
	        pxNetworkContext->socket_open = 1;
	        memcpy(pxNetworkContext->ipaddr, ipaddr, 4*sizeof(uint8_t));
	        pxNetworkContext->remote_port = MQTT_BROKER_PORT;

            // Forzamos éxito para romper el bucle
	        xNetworkStatus = PLAINTEXT_TRANSPORT_SUCCESS;
		}
    } while( ( xNetworkStatus != PLAINTEXT_TRANSPORT_SUCCESS ) );

    LOG(("--- [DEBUG] Saliendo de prvConnectToServer con EXITO ---\r\n"));
    return PLAINTEXT_TRANSPORT_SUCCESS;
}

void prvCreateMQTTConnectionWithBroker( MQTTContext_t * pxMQTTContext, NetworkContext_t * pxNetworkContext )
{
    // --- CHIVATO DE ENTRADA ---
    LOG(("--- [DEBUG] Entrando en prvCreateMQTTConnectionWithBroker ---\r\n"));

    MQTTStatus_t xResult;
    MQTTConnectInfo_t xConnectInfo;
    bool xSessionPresent;
    TransportInterface_t xTransport;

    HAL_Delay(500); // Estabilización

    init_transport_from_socket( pxNetworkContext->socket, 1, pxNetworkContext, &xTransport );

    xResult = MQTT_Init( pxMQTTContext, &xTransport, prvGetTimeMs, prvEventCallback, &xBuffer );
    configASSERT( xResult == MQTTSuccess );

    LOG(("--- [DEBUG] MQTT Init OK. Configurando paquete CONNECT... ---\r\n"));

    ( void ) memset( ( void * ) &xConnectInfo, 0x00, sizeof( xConnectInfo ) );
    xConnectInfo.cleanSession = true;
    xConnectInfo.pClientIdentifier = MQTTCLIENT_IDENTIFIER;
    xConnectInfo.clientIdentifierLength = ( uint16_t ) strlen( MQTTCLIENT_IDENTIFIER );
    xConnectInfo.pUserName = NULL;
    xConnectInfo.userNameLength = 0;
    xConnectInfo.pPassword = NULL;
    xConnectInfo.passwordLength = 0;
    xConnectInfo.keepAliveSeconds = 60U;

    LOG(("--- [MQTT] Enviando Packet CONNECT (Timeout 10s)... ---\r\n"));

    xResult = MQTT_Connect( pxMQTTContext,
                            &xConnectInfo,
                            NULL,
                            10000U,
                            &xSessionPresent );

    if(xResult == MQTTSuccess) {
         LOG(("--- [EXITO TOTAL] MQTT CONECTADO ---\r\n"));
    } else {
         LOG(("--- [ERROR] MQTT Connect Fallo. Codigo: %d ---\r\n", xResult));
    }
}

// RESTO DE FUNCIONES (Copia y pega esto también para asegurar que no falta nada)
void prvMQTTPublishToTopic( MQTTContext_t * pxMQTTContext, char * topic, void * payload ) {
    MQTTPublishInfo_t xMQTTPublishInfo;
    ( void ) memset( ( void * ) &xMQTTPublishInfo, 0x00, sizeof( xMQTTPublishInfo ) );
    xMQTTPublishInfo.qos = MQTTQoS0;
    xMQTTPublishInfo.retain = false;
    xMQTTPublishInfo.pTopicName = topic;
    xMQTTPublishInfo.topicNameLength = ( uint16_t ) strlen( topic );
    xMQTTPublishInfo.pPayload = payload;
    xMQTTPublishInfo.payloadLength = strlen( payload );
    MQTT_Publish( pxMQTTContext, &xMQTTPublishInfo, 0U );
}

void prvMQTTSubscribeToTopic( MQTTContext_t * pxMQTTContext, char * topic ) {
     MQTTSubscribeInfo_t xMQTTSubscription[ 1 ];
     usSubscribePacketIdentifier = MQTT_GetPacketId( pxMQTTContext );
     xMQTTSubscription[ 0 ].qos = MQTTQoS0;
     xMQTTSubscription[ 0 ].pTopicFilter = topic;
     xMQTTSubscription[ 0 ].topicFilterLength = strlen( topic );
     MQTT_Subscribe( pxMQTTContext, xMQTTSubscription, 1, usSubscribePacketIdentifier );
}

uint32_t prvGetTimeMs( void ) {
    return ( uint32_t ) xTaskGetTickCount() * ( 1000 / configTICK_RATE_HZ ) - ulGlobalEntryTimeMs;
}

void prvEventCallback( MQTTContext_t * pxMQTTContext, MQTTPacketInfo_t * pxPacketInfo, MQTTDeserializedInfo_t * pxDeserializedInfo ) {
    ( void ) pxMQTTContext;
    if( ( pxPacketInfo->type & 0xF0U ) == MQTT_PACKET_TYPE_PUBLISH ) {
      prvMQTTProcessIncomingPublish( pxDeserializedInfo->pPublishInfo );
    }
}

void prvMQTTProcessIncomingPublish( MQTTPublishInfo_t *pxPublishInfo ) {
	char buffer1[128];
	char buffer2[128];
	memcpy(buffer1,pxPublishInfo->pPayload,min(127,pxPublishInfo->payloadLength));
	buffer1[min(1023,pxPublishInfo->payloadLength)]='\0';
	memcpy(buffer2,pxPublishInfo->pTopicName,min(127,pxPublishInfo->topicNameLength));
	buffer2[min(1023,pxPublishInfo->topicNameLength)]='\0';
	LOG(("Topic \"%s\": publicado \"%s\"\n",buffer2,buffer1));
	if(buffer1[0]=='1') BSP_LED_On(LED2);
	if(buffer1[0]=='0') BSP_LED_Off(LED2);
}
